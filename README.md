# Практична робота №6
## Завдання 
### Умова
Встановіть Valgrind у Docker-образі з компілятором GCC, створіть просту програму на C і перевірте правильність встановлення (valgrind --version, valgrind ./a.out).
### Рішення
Для того, аби можна було подивитися на оцінити результати моєї роботи, я прикріпила в цей репозиторій [тестовий код](https://github.com/AnastasiiaVdovina/Practice6/blob/main/main.c) та [докер-файл](https://github.com/AnastasiiaVdovina/Practice6/blob/main/Dockerfile), який я використовувала для створення образу та запуску докер-контецнера в подальшому.

З [офіційного сайту Valgrind](https://valgrind.org/) я опрацювала інформацію з офіційної документації про те, як працює цей інструмент налагодження проблем з пам'яттю.
Для того, щоб протестувати його роботу, я створила просту програму на С, в якій в нас відбувається витік пам'яті через роботу malloc() без free().
У докер-файлі я прописала необхідні команди, яких вимагало завдання. А саме:
- Образ я будувала на основі мінімальної установки Debian Bullseye.
- apt-get install -y gcc valgrind - ця частина команди встановлює два пакети:
gcc - GNU Compiler Collection, набір компіляторів, включаючи компілятор C.
valgrind - інструмент для виявлення помилок пам'яті та профілювання.
- COPY main.c /main.c - копіює наш тестовий файл в контейнер
Для виконання останніх команд я використала sh щоб, виконати кілька команд як одну, а аргумент -c для /bin/sh дозволяє передати рядок, що містить одну або кілька команд, розділених операторами оболонки . У своєму випадку я використала && для послідовного виконання valgrind --version та valgrind /a.out.
Якби ми просто перерахували їх як окремі елементи масиву в CMD, це призвело б до виконання лише першої команди (valgrind --version), а решта були б проігноровані як аргументи до неї.

Після цих нескладних маніпуляцій та запуску контейнера командою
```
sudo docker run --rm valgrind-test
```

Я отримала наступне:

![image](https://github.com/user-attachments/assets/613d4f85-ff48-41ef-89d6-5e58a9631d57)

Аналізуючи результат можна сказати, що я використовувала інструмент Memcheck з Valgrind для виявлення проблем з пам'яттю.
Я дізналась версію Valgrind, яка тут використовується, як і вимагало завдання.
Далі ми отримуємо вивід резульататів роботи програми, яку я запустила під Valgrind(./a.out). Вона в мене просто виводить число, яке ми поклали в комірку пам'яті.
Бачимо, що програма двічі запитувала виділення пам'яті, один раз звільнила пам'ять, і загалом було виділено 4136 байтів.
definitely lost: 40 bytes in 1 blocks - це означає, що Valgrind виявив 40 байтів пам'яті в одному блоці, на які програма більше не має жодних посилань, і вони не були звільнені. Це і є явний витік пам'яті, який я намагалася тут побачити.
Головний підсумок повідомляє, що Valgrind виявив 1 помилку в 1 контексті (в даному випадку, це витік пам'яті). 

